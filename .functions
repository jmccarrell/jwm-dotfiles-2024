#!/usr/bin/env bash

# Create a new directory and enter it
function mkd() {
        mkdir -p "$@" && cd "$_";
}

# Determine size of a file or total size of a directory
function fs() {
        if du -b /dev/null > /dev/null 2>&1; then
                local arg=-sbh;
        else
                local arg=-sh;
        fi
        if [[ -n "$@" ]]; then
                du $arg -- "$@";
        else
                du $arg .[^.]* ./*;
        fi;
}

# Use Git’s colored diff when available
hash git &>/dev/null;
if [ $? -eq 0 ]; then
        function diff() {
                git diff --no-index --color-words "$@";
        }
fi;

# Compare original and gzipped file size
function gz() {
        local origsize=$(wc -c < "$1");
        local gzipsize=$(gzip -c "$1" | wc -c);
        local ratio=$(echo "$gzipsize * 100 / $origsize" | bc -l);
        printf "orig: %d bytes\n" "$origsize";
        printf "gzip: %d bytes (%2.2f%%)\n" "$gzipsize" "$ratio";
}

# UTF-8-encode a string of Unicode symbols
function escape() {
        printf "\\\x%s" $(printf "$@" | xxd -p -c1 -u);
        # print a newline unless we’re piping the output to another program
        if [ -t 1 ]; then
                echo ""; # newline
        fi;
}

# Decode \x{ABCD}-style Unicode escape sequences
function unidecode() {
        perl -e "binmode(STDOUT, ':utf8'); print \"$@\"";
        # print a newline unless we’re piping the output to another program
        if [ -t 1 ]; then
                echo ""; # newline
        fi;
}

# Get a character’s Unicode code point
function codepoint() {
        perl -e "use utf8; print sprintf('U+%04X', ord(\"$@\"))";
        # print a newline unless we’re piping the output to another program
        if [ -t 1 ]; then
                echo ""; # newline
        fi;
}

# Show all the names (CNs and SANs) listed in the SSL certificate
# for a given domain
function getcertnames() {
        if [ -z "${1}" ]; then
                echo "ERROR: No domain specified.";
                return 1;
        fi;

        local domain="${1}";
        echo "Testing ${domain}…";
        echo ""; # newline

        local tmp=$(echo -e "GET / HTTP/1.0\nEOT" \
                | openssl s_client -connect "${domain}:443" -servername "${domain}" 2>&1);

        if [[ "${tmp}" = *"-----BEGIN CERTIFICATE-----"* ]]; then
                local certText=$(echo "${tmp}" \
                        | openssl x509 -text -certopt "no_aux, no_header, no_issuer, no_pubkey, \
                        no_serial, no_sigdump, no_signame, no_validity, no_version");
                echo "Common Name:";
                echo ""; # newline
                echo "${certText}" | grep "Subject:" | sed -e "s/^.*CN=//" | sed -e "s/\/emailAddress=.*//";
                echo ""; # newline
                echo "Subject Alternative Name(s):";
                echo ""; # newline
                echo "${certText}" | grep -A 1 "Subject Alternative Name:" \
                        | sed -e "2s/DNS://g" -e "s/ //g" | tr "," "\n" | tail -n +2;
                return 0;
        else
                echo "ERROR: Certificate not found.";
                return 1;
        fi;
}

# `o` with no arguments opens the current directory, otherwise opens the given
# location
# function o() {
#       if [ $# -eq 0 ]; then
#               open .;
#       else
#               open "$@";
#       fi;
# }

# `tre` is a shorthand for `tree` with hidden files and color enabled, ignoring
# the `.git` directory, listing directories first. The output gets piped into
# `less` with options to preserve color and line numbers, unless the output is
# small enough for one screen.
function tre() {
        tree -aC -I '.git|node_modules|bower_components' --dirsfirst "$@" | less -FRNX;
}

#
# jeffs functions
#

# is this a persona laptop we are running on?
function persona_host_p {
    dir=$HOME/Jts
    if [[ -e $dir && -d $dir ]]; then
        return 1;
    fi;
    return 0;
}

# join an array into a string
#  from https://stackoverflow.com/questions/1527049/join-elements-of-an-array
# join_by ' , ' a b c
#  gives
# a , b , c
function join_by { local d=$1; shift; echo -n "$1"; shift; printf "%s" "${@/#/$d}"; }

#
# select the JVM version in use
#
# see all versions with -V/--verbose
#  set a version with -v/--version
#  cf: https://www.kevinhooke.com/2017/10/05/switching-java-versions-on-mac-os/
function jwm_prefer_java_8 {
    export JAVA_HOME=$(/usr/libexec/java_home --version 1.8)
}

function jwm_prefer_java_11 {
    export JAVA_HOME=$(/usr/libexec/java_home --version 11)
}

#
# end jeffs functions
#
